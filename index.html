<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Team Flow Map (Year × Section × Group)</title>

<!-- TailwindCSS -->
<script src="https://cdn.tailwindcss.com"></script>

<!-- D3.js（ズーム用＋線の描画用） -->
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

<style>
  body {
    margin: 0;
    overflow: auto;
    background: #f3f4f6;
  }
  .cluster-card {
    transition: transform 0.15s ease, box-shadow 0.15s ease, opacity 0.15s ease;
  }
  .cluster-card:hover {
    z-index: 1000;
    box-shadow: 0 8px 16px rgba(0,0,0,0.25);
  }
  .year-label {
    font-weight: bold;
    font-size: 18px;
  }
  .section-label {
    font-weight: bold;
    font-size: 18px;
  }
</style>
</head>

<body>

<div id="viewport" class="w-screen h-screen overflow-auto relative">
  <div id="zoom-wrapper" class="origin-top-left relative">
    <svg id="lines" class="absolute top-0 left-0 pointer-events-none"></svg>
    <div id="container" class="absolute top-0 left-0"></div>
  </div>
</div>

<script>
// -----------------------------
// 外部JSON読み込み
// -----------------------------
fetch("./data.json")
  .then(res => res.json())
  .then(raw => init(raw));

function init(rawData) {
  // -----------------------------
  // データ正規化
  // -----------------------------
  const data = rawData.map(d => ({
    ...d,
    year: Number(d.year),
    section: String(d.section).trim(),
    group: String(d.group).trim()
  }));

  // 年・セクション一覧
  const years = [...new Set(data.map(d => d.year))].sort((a,b)=>a-b);
  const sectionNames = [...new Set(data.map(d => d.section))].sort();

  // セクション色パレット
  const palette = [
    "#4CAF50","#2196F3","#FF9800","#9C27B0","#009688",
    "#E91E63","#3F51B5","#795548","#607D8B","#FFC107"
  ];

  // -----------------------------
  // クラスタ（year × section × group）を作る
  // -----------------------------
  const clusterMap = {};
  data.forEach(p => {
    const key = `${p.year}|${p.section}|${p.group}`;
    if (!clusterMap[key]) {
      clusterMap[key] = {
        year: p.year,
        section: p.section,
        group: p.group,
        members: []
      };
    }
    clusterMap[key].members.push(p);
  });
  const clusters = Object.values(clusterMap);

  // -----------------------------
  // セクションごとの班一覧（クラスタから作り直す）
  // -----------------------------
  const sections = sectionNames.map((name, idx) => {
    const groups = [...new Set(
      clusters.filter(c => c.section === name).map(c => c.group)
    )].sort();
    return {
      name,
      color: palette[idx % palette.length],
      groups
    };
  });

  // -----------------------------
  // レイアウト寸法
  // -----------------------------
  const yearHeight = 260;
  const baseCardWidth = 160;
  const baseCardHeight = 40;
  const nameLineHeight = 18;
  const yearTopMargin = 70;
  const leftYearLabelWidth = 80;
  const sectionGap = 60;
  const groupGap = 20;

  const zoomWrapper = document.getElementById("zoom-wrapper");
  const container = document.getElementById("container");
  const svg = d3.select("#lines");

  // -----------------------------
  // セクションごとのXオフセット計算（班数に応じて可変）
  // -----------------------------
  const sectionOffsets = {};
  let currentX = leftYearLabelWidth + 40;

  sections.forEach(sec => {
    const widthForSection = sec.groups.length * (baseCardWidth + groupGap);
    sectionOffsets[sec.name] = {
      x: currentX,
      width: widthForSection
    };
    currentX += widthForSection + sectionGap;
  });

  // -----------------------------
  // 年ラベル
  // -----------------------------
  years.forEach((year, yi) => {
    const yPos = yearTopMargin + yi * yearHeight;
    const label = document.createElement("div");
    label.className = "absolute year-label text-gray-700";
    label.style.left = "16px";
    label.style.top = `${yPos + 10}px`;
    label.textContent = `${year} 年`;
    container.appendChild(label);
  });

  // -----------------------------
  // セクションラベル
  // -----------------------------
  sections.forEach(sec => {
    const info = sectionOffsets[sec.name];
    const centerX = info.x + info.width / 2;
    const label = document.createElement("div");
    label.className = "absolute section-label text-gray-800";
    label.style.top = "10px";
    label.style.left = `${centerX - 40}px`;
    label.textContent = sec.name;
    container.appendChild(label);
  });

  // -----------------------------
  // クラスタを描画
  // -----------------------------
  const nodes = []; // [ {year, section, group, x, y, width, height, color, members} ]

  clusters.forEach(cluster => {
    const yi = years.indexOf(cluster.year);
    if (yi === -1) return; // 念のため

    const secInfo = sections.find(s => s.name === cluster.section);
    if (!secInfo) return;

    const secOffset = sectionOffsets[cluster.section];
    const gi = secInfo.groups.indexOf(cluster.group);
    if (gi === -1) return;

    const x = secOffset.x + gi * (baseCardWidth + groupGap);
    const y = yearTopMargin + yi * yearHeight;

    const members = cluster.members;
    const cardWidth = baseCardWidth;

    // 高さは中身に任せる（人数分だけ自然に伸びる）
    const card = document.createElement("div");
    card.className =
      "cluster-card absolute bg-white rounded-lg border px-3 py-2 shadow-sm cursor-pointer";
    card.style.left = `${x}px`;
    card.style.top = `${y}px`;
    card.style.width = `${cardWidth}px`;
    card.style.borderColor = secInfo.color;
    card.dataset.year = cluster.year;

    let inner = `
      <div class="text-xs font-semibold text-gray-700 mb-1">
        ${cluster.group}（${members.length}人）
      </div>
      <div class="text-[11px] leading-tight text-gray-700">
    `;
    members.forEach(m => {
      inner += `<div>・${m.name}</div>`;
    });
    inner += `</div>`;

    card.innerHTML = inner;
    container.appendChild(card);

    // 実際の高さを取るため、一旦 DOM に追加してから取得
    const rect = card.getBoundingClientRect();
    const height = rect.height;

    nodes.push({
      year: cluster.year,
      section: cluster.section,
      group: cluster.group,
      members,
      x,
      y,
      width: cardWidth,
      height,
      color: secInfo.color
    });

    // 同期ホバー（同じ年の枠を強調）
    card.addEventListener("mouseenter", () => highlightYear(cluster.year));
    card.addEventListener("mouseleave", () => resetHighlight());
  });

  // -----------------------------
  // 班ごとに枠を縦に線でつなぐ
  // -----------------------------
  sections.forEach(sec => {
    sec.groups.forEach(groupName => {
      const list = nodes
        .filter(n => n.section === sec.name && n.group === groupName)
        .sort((a,b) => a.year - b.year);

      for (let i = 0; i < list.length - 1; i++) {
        const a = list[i];
        const b = list[i+1];

        svg.append("line")
          .attr("x1", a.x + a.width / 2)
          .attr("y1", a.y + a.height)
          .attr("x2", b.x + b.width / 2)
          .attr("y2", b.y)
          .attr("stroke", a.color)
          .attr("stroke-width", 3)
          .attr("opacity", 0.7);
      }
    });
  });

  // -----------------------------
  // SVG & wrapper サイズ
  // -----------------------------
  const maxX = Math.max(...nodes.map(n => n.x + n.width)) + 80;
  const maxY = Math.max(...nodes.map(n => n.y + n.height)) + 80;

  zoomWrapper.style.width = `${maxX}px`;
  zoomWrapper.style.height = `${maxY}px`;
  svg.attr("width", maxX).attr("height", maxY);

  // -----------------------------
  // 同期ホバー強調
  // -----------------------------
  function highlightYear(targetYear) {
    document.querySelectorAll(".cluster-card").forEach(card => {
      const y = Number(card.dataset.year);
      if (y === targetYear) {
        card.style.transform = "scale(1.06)";
        card.style.opacity = "1";
        card.style.zIndex = "1000";
      } else {
        card.style.transform = "scale(0.94)";
        card.style.opacity = "0.35";
        card.style.zIndex = "1";
      }
    });
  }

  function resetHighlight() {
    document.querySelectorAll(".cluster-card").forEach(card => {
      card.style.transform = "scale(1)";
      card.style.opacity = "1";
      card.style.zIndex = "1";
    });
  }

  // -----------------------------
  // ズーム & パン（控えめ中央寄せ）
  // -----------------------------
  const zoom = d3.zoom()
    .scaleExtent([0.5, 2])
    .on("zoom", ev => {
      zoomWrapper.style.transform = `
        translate(${ev.transform.x}px, ${ev.transform.y}px)
        scale(${ev.transform.k})
      `;
    });

  const selection = d3.select("#viewport");
  selection.call(zoom);

  const initialX = window.innerWidth * 0.2;
  const initialY = 40;

  selection.call(
    zoom.transform,
    d3.zoomIdentity.translate(initialX, initialY).scale(1)
  );
}
</script>

</body>
</html>
